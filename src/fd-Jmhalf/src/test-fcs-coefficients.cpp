#include "Common.h"
#include "FileSys.h"
#include "FullyConvergedSeries.h"
#include <chrono>

namespace {

    // Коэффициенты для индекса k = -1/2
    const BmpVector b_mhalf = {
        1.00000000000000022, -0.41421356237309515, 0.48097395201231308, -0.31443745684377605, 0.35496973905796525, -0.26391469912742610, 0.29305220065772453,
       -0.23206012422784597, 0.25480909731988405, -0.20961507725316636, 0.22827198241767724, -0.19269402581588935, 0.20850412514677033, -0.17934271566143664,
        0.19305732762114028, -0.16845640223916253, 0.18056386586844170, -0.15935707527675091, 0.17019275877281642, -0.15160238383284011, 0.16140657992677773,
       -0.14488973151960657, 0.15384051431503362, -0.13900414944762135, 0.14723715862015460, -0.13378812964569098, 0.14140906612540924, -0.12912325802251828,
        0.13621609350926644, -0.12491855193815647, 0.13155110392581695, -0.12110278860777168, 0.12733061461119022,-0.11761930413804721, 0.12348848883008756,
       -0.11442237441589655, 0.11997156715133331, -0.11147463877385461, 0.11673657115056887, -0.10874522884795892, 0.11374786384105723, -0.10620838520960593,
        0.11097580026521373, -0.10384241822419096, 0.10839549296611649, -0.10162891623985279, 0.10598587447494355, -0.09955213438673234, 0.10372897595078695,
       -0.09759851721451281, 0.10160936547917465, -0.09575632184163210, 0.09961370590635248, -0.09401531751504925, 0.09773040328255238, -0.09236654391281224,
        0.09594932477105972, -0.09080211507512911, 0.09426157037285680, -0.08931505911688105,  0.09265928674694333, -0.08789918624863347, 0.09113551425473627,
       -0.08654897937862024, 0.08968406044561429, -0.08525950286539473,  0.08829939474918186, -0.08402632596474541,
    };

    // Вычислить коэффициенты всюду сходящегося ряда Интегральной ФД
    BmpVector calculate(size_t N) {
        BmpVector cn = { 1.0 / 2 };
        for (size_t n = 1; n < N; ++n) {
            BmpReal sum = 0;
            for (size_t p = 0; p <= n; ++p) {
                sum += b_mhalf.at(p)*b_mhalf.at(n - p);
            }
            BmpReal result = ((n + 1)*cn.at(n - 1) + sum) / (n + 2);
            cn.push_back(result);
        }
        return cn;
    }

    void checkAccuracy(BmpReal x, BmpReal left, BmpReal right) {
        setPreciseOutput();
        std::cout << " x = " << x << ", d = " << left / right - 1 << std::endl;
    }

}

TEST_CASE("coefficients") {
    INFO("Вычисление коэффициентов всюду сходящегося ряда для интегральной ФД");
    nlohmann::json coefficients = calculate(67);
    filesys::writeFile("Jmhalf-fcs-cn.json", coefficients);
}

TEST_CASE("calculate") {
    INFO("Вычисление интегральной ФД в точке x = 0");
    setPreciseOutput();
    std::cout << fcs::calculateJmhalf(0) << std::endl;
    for (auto x : {-2.0, -1.0, 0.0}) {
        auto start = std::chrono::steady_clock::now();
        std::cout << fcs::calculateJmhalf(x) << std::endl;
        auto end = std::chrono::steady_clock::now();
        auto elapsed_ms = std::chrono::duration_cast<std::chrono::milliseconds>(end - start);
        std::cout << "calc x = " << x << " time: " << elapsed_ms.count() << "ms" << std::endl;
    }
}

/**
 * gsl
 * x = -2, I = 0.025488904217813014
 * x = -1, I = 0.15685317601594415
 * x = 0, I = 0.78323866983319235
 * x = 5, I = 46.589187519238614
 * x = 10, I = 194.03517728526793
 * x = 15, I = 442.65704119530864
 * x = 20, I = 791.69654571653882
 * x = 25, I = 1240.9561165133962
 * x = 30, I = 1790.352916150179
 * x = 35, I = 2439.843753194812
 * x = 40, I = 3189.4031422038
 * x = 45, I = 4039.014755720504
 * x = 50, I = 4988.667493982043
 */
namespace {
    const BmpVector INTEGRAL_RES = {
        0.02548890421781356,
        0.15685317601594093,
        0.783238669833194,
    };
    const BmpVector GSL_RES = {
        0.025488904217813014,
        0.15685317601594415,
        0.78323866983319235,
    };
}

TEST_CASE("accuracy") {
    SECTION("quad_fcs") {
        double x = -2.0;
        for (auto value : INTEGRAL_RES) {
            checkAccuracy(x, fcs::calculateJmhalf(x), value);
            ++x;
        }
    }
    SECTION("gsl_fcs") {
        double x = -2.0;
        for (auto value : GSL_RES) {
            checkAccuracy(x, fcs::calculateJmhalf(x), value);
            ++x;
        }
    }
    SECTION("gsl_quad") {
        double x = -2.0;
        for (int i = 0; i < GSL_RES.size(); ++i) {
            checkAccuracy(x, GSL_RES[i], INTEGRAL_RES[i]);
            ++x;
        }
    }
}