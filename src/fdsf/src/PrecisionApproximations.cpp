/**
* Реализация вычисления функций ФД с помощью прецизионных формул
* TODO: Добавить для полуцелых индексов, интегральной функции
*/

#include "PrecisionApproximations.h"
#include "FdIndex.h"
#include "Errors.h"
#include "Gamma.h"

namespace {

    // Возвращает коэффициенты числителя для заданного индекса
    const BmpVector nomParamsByIndex(BmpReal k) {
        if (fdsf::index::P1 == k) {
            return { 1,
                     0.271511313821436278,
                     0.056266123806058763,
                     0.006742074046934569,
                     0.000516950515533321,
                     0.000019477183676577,
            };
        } else if (fdsf::index::P2 == k) {
            return { 1,
                     0.226381636434069856,
                     0.053368433557479886,
                     0.006290475634079521,
                     0.000502322827445298,
                     0.000018937967508806,
            };
        } else if (fdsf::index::P3 == k) {
            return { 1,
                     0.158348214538045596,
                     0.046064514990930811,
                     0.004886137910884147,
                     0.000433673330597152,
                     0.000017343561379589,
            };
        } else if (fdsf::index::P4 == k) {
            return { 1,
                     0.056014879123090215,
                     0.035111795789180087,
                     0.002183438694367233,
                     0.000246486152552295,
                     0.000009222817788667,
            };
        } else if (fdsf::index::M3_HALF == k) {
            return { 1,
                     0.2688820711296041,
                     0.0866553463563448,
                     0.0146274105301976,
                     0.0022393408692306,
                     0.0002199735562638,
                     0.0000150378495161,
                     0.0000005300086453,
            };
        } else if (fdsf::index::M1_HALF == k) {
            return { 1,
                     0.6640127109145859,
                     0.2191510514850044,
                     0.0464790835515895,
                     0.0068629385714155,
                     0.0007116343947399,
                     0.0000486792692203,
                     0.0000017396984262,
            };
        } else if (fdsf::index::P1_HALF == k) {
            return { 1,
                     0.4230390367951766,
                     0.1150948861362855,
                     0.0211596194006563,
                     0.0028109730001318,
                     0.0002646450259842,
                     0.0000163590289177,
                     0.0000005184504861,
            };
        } else if (fdsf::index::P3_HALF == k) {
            return { 1,
                     0.3517319249901851,
                     0.0984324632040061,
                     0.0173479499452508,
                     0.0023078720422010,
                     0.0002155281360801,
                     0.0000133682592746,
                     0.0000004285240789,
            };
        } else if (fdsf::index::P5_HALF == k) {
            return { 1,
                     0.3881674670557970,
                     0.1147433796554936,
                     0.0218267752298646,
                     0.0030904362270756,
                     0.0003034214803112,
                     0.0000194262753763,
                     0.0000006251432603,
            };
        } else if (fdsf::index::P7_HALF == k) {
            return { 1,
                     0.2644820711296041,
                     0.0868553463563448,
                     0.0148274105301976,
                     0.0022093408692306,
                     0.0002199735562638,
                     0.0000150378495161,
                     0.0000005300086453,
            };
        }
        throw UnsupportedFdFunction();
    }

    // Возвращает коэффициенты знаменателя для заданного индекса
    const BmpVector denomParamsByIndex(BmpReal k) {
        if (fdsf::index::P1 == k) {
            return{ 1,
                    0.021511313821435284,
                    0.023110517572972142,
                    0.000366908157736541,
                    0.000061042440873272,
            };
        } else if (fdsf::index::P2 == k) {
            return{ 1,
                0.038881636434069113,
                0.024304399874277445,
                0.000629098532643319,
                0.000065701816194546,
            };
        } else if (fdsf::index::P3 == k) {
            return{ 1,
                    0.012514881204710761,
                    0.026669340700092963,
                    0.000328543109454736,
                    0.000082091078789006,
            };
        } else if (fdsf::index::P4 == k) {
            return{ 1,
                   -0.061172620876911286,
                    0.027996854281614683,
                   -0.000751214829430754,
                    0.000086068074714292,
            };
        } else if (fdsf::index::M3_HALF == k) {
            return{ 1,
                    0.2135628061151275,
                    0.0584377763837145,
                    0.0074283707132822,
                    0.0008328205277427,
                    0.0000504390414839,
                    0.0000016957551378,
            };
        } else if (fdsf::index::M1_HALF == k) {
            return{ 1,
                    0.2497991485411669,
                    0.0608215091948263,
                    0.0083405548692429,
                    0.0009408691779758,
                    0.0000598703110920,
                    0.0000022661201302,
            };
        } else if (fdsf::index::P1_HALF == k) {
            return{ 1,
                    0.1301458179817451,
                    0.0444027175790622,
                    0.0040809614661287,
                    0.0005222693769483,
                    0.0000264461085702,
                    0.0000009662169431,
            };
        } else if (fdsf::index::P3_HALF == k) {
            return{ 1,
                    0.1362497218545711,
                    0.0446545504100611,
                    0.0042646774681703,
                    0.0005255577863508,
                    0.0000277440057305,
                    0.0000009933811452,
            };
        } else if (fdsf::index::P5_HALF == k) {
            return{ 1,
                    0.2235228061151275,
                    0.0584077763837145,
                    0.0074783707132822,
                    0.0008328205277427,
                    0.0000504390414839,
                    0.0000016957551378,
            };
        } else if (fdsf::index::P7_HALF == k) {
            return{ 1,
                    0.1342518350793086,
                    0.0535429414639100,
                    0.0052275574401635,
                    0.0007578425032921,
                    0.0000427956998856,
                    0.0000017184679983,
            };
        }
        throw UnsupportedFdFunction();
    }
}

namespace prec_approx_formula {
    // Вычислить левую аппроксимацию в точке для заданного k
    BmpReal calculateLeft(BmpReal k, BmpReal x) {
        BmpReal y = log(1 + exp(x));
        BmpVector params = nomParamsByIndex(k);
        BmpReal nominator = 0;
        for (size_t i = 0; i < params.size(); ++i) {
            nominator += params.at(i) * pow(y, i);
        }
        params = denomParamsByIndex(k);
        BmpReal denominator = 0;
        for (size_t i = 0; i < params.size(); ++i) {
            denominator += params.at(i) * pow(y, i);
        }
        return factorial(k)*y*pow(nominator / denominator, k);
    }

}
